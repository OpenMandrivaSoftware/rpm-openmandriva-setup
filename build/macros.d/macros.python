# Python specific macro definitions.
# To make use of these macros insert the following line into your spec file:
# %{load:%{_rpmconfigdir}/macros.d/python}

%__python	%{_bindir}/python

%python_sitearch %(%{__python} -c "import os; from distutils.sysconfig import get_python_lib; lib=get_python_lib(1); print(os.path.islink(lib) and os.path.abspath(os.path.join(os.path.dirname(lib),os.readlink(lib))) or lib)")
%python_sitelib	%(%{__python} -c "import os; from distutils.sysconfig import get_python_lib; lib=get_python_lib(); print(os.path.islink(lib) and os.path.abspath(os.path.join(os.path.dirname(lib),os.readlink(lib))) or lib)")
%python_version	%(%{__python} -c "import sys; print(sys.version[0:3])")

# python main version
%py_ver                 %(%{__python} -c "import sys; v=sys.version_info[:2]; print('%%d.%%d'%%v)" 2>/dev/null || echo PYTHON-NOT-FOUND)
%py_prefix              %(%{__python} -c "import sys; print(sys.prefix)" 2>/dev/null || echo PYTHON-NOT-FOUND)
%py_platlibdir          %(%{__python} -c 'import distutils.sysconfig; print(distutils.sysconfig.get_python_lib(standard_lib=1,plat_specific=1))' 2>/dev/null || echo PYTHON-LIBDIR-NOT-FOUND)
%py_purelibdir          %(%{__python} -c 'import distutils.sysconfig; print(distutils.sysconfig.get_python_lib(standard_lib=1,plat_specific=0))' 2>/dev/null || echo PYTHON-LIBDIR-NOT-FOUND)
# backward compatibility
%py_libdir              %py_purelibdir

%py_platsitedir         %(%{__python} -c 'import distutils.sysconfig; print(distutils.sysconfig.get_python_lib(plat_specific=1))' 2>/dev/null || echo PYTHON-LIBDIR-NOT-FOUND)
%py_puresitedir         %(%{__python} -c 'import distutils.sysconfig; print(distutils.sysconfig.get_python_lib())' 2>/dev/null || echo PYTHON-LIBDIR-NOT-FOUND)
%py_sitedir             %py_puresitedir

%py_dyndir		%{py_platlibdir}/lib-dynload

%py_incdir              %(%{__python} -c 'import distutils.sysconfig; print(distutils.sysconfig.get_python_inc())' 2>/dev/null || echo PYTHON-INCLUDEDIR-NOT-FOUND)

%py_compile(O)  \
find %1 -name '*.pyc' -exec rm -f {} \\; \
%{__python} -c "import sys, os, compileall; br='%{buildroot}'; compileall.compile_dir(sys.argv[1], ddir=br and (sys.argv[1][len(os.path.abspath(br)):]+'/') or None)" %1 \
%{-O: \
find %1 -name '*.pyo' -exec rm -f {} \\; \
%{__python} -O -c "import sys, os, compileall; br='%{buildroot}'; compileall.compile_dir(sys.argv[1], ddir=br and (sys.argv[1][len(os.path.abspath(br)):]+'/') or None)" %1 \
}

# pure python modules compilation
%py_comp	%{__python} -c "import compileall; import sys; compileall.compile_dir(sys.argv[1], ddir=sys.argv[1][len('%{buildroot}'):])"

%py_ocomp	%{__python} -O -c "import compileall; import sys; compileall.compile_dir(sys.argv[1], ddir=sys.argv[1][len('%{buildroot}'):])"

%py_setup setup.py
%py_shbang_opts -s

%py_build() %{expand:\\\
  CFLAGS="%{optflags}" %{__python} %{py_setup} %{?py_setup_args} build --executable="%{__python} %{py_shbang_opts}" %{?*}
  sleep 1
}

%py_install() %{expand:\\\
  CFLAGS="%{optflags}" %{__python} %{py_setup} %{?py_setup_args} install -O1 --skip-build --root %{buildroot} %{?*}
}

%py_requires(d) \
BuildRequires: %{__python} %{-d:python-devel}

# Should python bytecompilation errors terminate a build?
%_python_bytecompile_errors_terminate_build 1

# Enable python bytecompilation
%_python_bytecompile_build 1

# For migration from packages names "python-foo" to "python2-foo"
%py2_migration_meta() \
%define py2_migration_rn %(echo %{1} | sed -e 's,^python2-,python-,g' | grep '^python-') \
%{expand:\
Provides: %{py2_migration_rn} = %{EVRD} \
Conflicts: %{py2_migration_rn} < %{EVRD} \
Obsoletes: %{py2_migration_rn} < %{EVRD} \
}

# rosa2019.1+ names packages as python2-foo
# rosa2016.1 names them as python-foo
# Allow to name as %%python2-foo
%python2 python2

# From Fedora
# Macro to replace overly complicated references to PyPI source files.
# Expands to the pythonhosted URL for a package
# Accepts zero to three arguments:
# 1:  The PyPI project name, defaulting to %srcname if it is defined, then
#     %pypi_name if it is defined, then just %name.
# 2:  The PYPI version, defaulting to %version.
# 3:  The file extension, defaulting to "tar.gz".  (A period will be added
#     automatically.)
# Requires %__pypi_url and %__pypi_default_extension to be defined.
%__pypi_url https://files.pythonhosted.org/packages/source/
%__pypi_default_extension tar.gz
%pypi_source() %{lua:
    local src = rpm.expand('%1')
    local ver = rpm.expand('%2')
    local ext = rpm.expand('%3')
    local url = rpm.expand('%__pypi_url')
\
    -- If no first argument, try %srcname, then %pypi_name, then %name
    -- Note that rpm leaves macros unchanged if they are not defined.
    if src == '%1' then
        src = rpm.expand('%srcname')
    end
    if src == '%srcname' then
        src = rpm.expand('%pypi_name')
    end
    if src == '%pypi_name' then
        src = rpm.expand('%name')
    end
\
    -- If no second argument, use %version
    if ver == '%2' then
        ver = rpm.expand('%version')
    end
\
    -- If no third argument, use the preset default extension
    if ext == '%3' then
        ext = rpm.expand('%__pypi_default_extension')
    end
\
    local first = string.sub(src, 1, 1)
\
    print(url .. first .. '/' .. src .. '/' .. src .. '-' .. ver .. '.' .. ext)
}
